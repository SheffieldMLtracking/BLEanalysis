import numpy as np
import matplotlib.pyplot as plt
from BLEanalysis.signals import Signals

class SimpleDemo:
    def get_location_at_time(self,t):
        return np.array([(1*t)*10+10,(1*t)*10])
    def __init__(self,obstimes=None):
        """Create simple straight line, synthetic data
        
        obstimes = the times that the bursts will happen.
        """
        
        # Location of transmitters
        a = [28,40]
        e = [63,15]
        self.stationlocations = np.array([a,e])
        # Time for each observation in order that observations are stored in observations[]
        if obstimes is None:
            print("Using default observation times")
            obstimes = np.linspace(0,5,30)
            print(obstimes)
        self.obstimes = obstimes

        # Populate observations[] with [x, y, z] vectors
        self.observations = []
        self.trueLocations = []
        for i,t in enumerate(self.obstimes):
            #location = np.array([(1*t)*10+10 + np.random.randint(1,5),(1*t)*10 + np.random.randint(1,5)]) #TODO: @Chris - why is their so much white noise added to the location?!
            location = self.get_location_at_time(t)
            vect = location-self.stationlocations
            vect/= np.linalg.norm(vect,axis=1)[:,None]
            possibleobs = np.c_[self.stationlocations,vect]
            obs = possibleobs[i%2,:]
            self.observations.append(obs)
            self.trueLocations.append(location)
        # observations[observer_x, observer_y, observer_z (unused), observation_x, observation_y, observation_z (unused)]
        # NOTE: Need to convert bearing in radians to directional vector
        # V.x = cos(B)
        # V.y = sin(B)
        self.observations = np.array(self.observations)
        # Tuples of x,y,z(unused) coords in order
        self.trueLocations = np.array(self.trueLocations)

    def plot(self):
        """Plot synthetic data
        
        TODO Switch to using axis object
        """
        plt.axis('equal')
        plt.plot(self.trueLocations[:,0],self.trueLocations[:,1],'x-')
        plt.axis('equal')
        for obs in self.observations:
            plt.plot([obs[0],obs[0]+obs[2]*30],[obs[1],obs[1]+obs[3]*30],color='grey',alpha=0.1)
        plt.title("Synthetic Path")
        plt.xlabel("x coords")
        plt.ylabel("y coords")
        
class SignalDemo(SimpleDemo):
    def __init__(self,burst_length = 1500,sample_interval = 100,sigs=None,obstimes=None):
        """
        Generate a synthetic burst for each observation, using the observations generated by "SimpleDemo" (parent class).
        Store as a list of dictionaries in self.observations.
        """
        super().__init__(obstimes)
        if sigs is None: #TODO How to make this always find this file...
            sigs = Signals("../bluetooth_experiments/no rf amp experiments/noamploc2long.log",'d',angleOffset = 38)
        
        new_observations = []
        for obs in self.observations:
            synthetic_angle = np.arctan2(obs[3],obs[2])
            data_rssis,data_angles = sigs.getSample(burst_length, sample_interval,exclude_missing=20)
            new_obs = {'transmitter_position':obs[:2],'rssis':data_rssis,'angles':data_angles-synthetic_angle}
            
            new_observations.append(new_obs)
        self.burst_observations = new_observations
